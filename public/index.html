<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Bookmarklet Quine Editor</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link rel="icon" type="image/png" href="data:image/png;base64,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">
	<meta author="https://github.com/hagb4rd">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:url"                content="http://www.nytimes.com/2015/02/19/arts/international/when-great-minds-dont-think-alike.html" />
	<meta property="og:type"               content="article" />
	<meta property="og:title"              content="Bookmarklet Quine Editor" />
	<meta property="og:description"        content="Drag the created Link into the your bookmark bar to inject this editor in your website." />
	<meta property="og:image"              content="https://i.imgur.com/zciWZmd.jpg" />
	<script src="https://cdn.rawgit.com/hagb4rd/ea-webkit/master/dist/webkit.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/ace.js"></script>
	<script src="Event.js"></script>
	<script src="ColorSphereBackground.js"></script>

	<style>
		body {
			margin: 0px;
			padding: 0px;

			font-family: Robo;
			background-color: rgb(40, 90, 108);
		}

		.blende {
			position: relative;
			overflow: hidden;
			height: 800px;
			margin: 1.5em 0 0 0;
		}

		.blende img {
			height: 800px;
		}

		.blende img.zoom {
			-webkit-transform: scale(2.6) rotate(0.1deg);
			-moz-transform: scale(2.6) rotate(0.1deg);
		}

		#footer {
			border-top: 1px solid rgba(0, 0, 0, 0.25);
			overflow: hidden;
			padding: 0 auto;
			margin: 0 auto;
			width: 100%;
			position: absolute;
			z-index: 0;
			height: 100%;
		}

		#footer:after {
			content: " ";
			background: url('interlace-diagonal-light.png');
			width: 100%;
			height: inherit;
			position: absolute;
			top: 0;
			left: 0;
			z-index: 0;
		}
	</style>
</head>
<body onLoad="">
<script>
		/*
		----------------------------------------------------
		Event.js : 1.1.4 : 2013/09/15 : MIT License
		----------------------------------------------------
		https://github.com/mudcube/Event.js
		----------------------------------------------------
		1  : click, dblclick, dbltap
		1+ : tap, longpress, drag, swipe
		2+ : pinch, rotate
			 : mousewheel, devicemotion, shake
		----------------------------------------------------
		Ideas for the future
		----------------------------------------------------
		* GamePad, and other input abstractions.
		* Event batching - i.e. for every x fingers down a new gesture is created.
		----------------------------------------------------
		http://www.w3.org/TR/2011/WD-touch-events-20110505/
		----------------------------------------------------
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	
	(function(root) { "use strict";
	
	// Add custom *EventListener commands to HTMLElements (set false to prevent funkiness).
	root.modifyEventListener = false;
	
	// Add bulk *EventListener commands on NodeLists from querySelectorAll and others  (set false to prevent funkiness).
	root.modifySelectors = false;
	
	// Event maintenance.
	root.add = function(target, type, listener, configure) {
		return eventManager(target, type, listener, configure, "add");
	};
	
	root.remove = function(target, type, listener, configure) {
		return eventManager(target, type, listener, configure, "remove");
	};
	
	root.stop = function(event) {
		if (!event) return;
		if (event.stopPropagation) event.stopPropagation();
		event.cancelBubble = true; // <= IE8
		event.bubble = 0;
	};
	
	root.prevent = function(event) {
		if (!event) return;
		if (event.preventDefault) event.preventDefault();
		if (event.preventManipulation) event.preventManipulation(); // MS
		event.returnValue = false; // <= IE8
	};
	
	root.cancel = function(event) {
		root.stop(event);
		root.prevent(event);
	};
	
	root.blur = function() { // Blurs the focused element. Useful when using Event.cancel as canceling will prevent focused elements from being blurred.
		var node = document.activeElement;
		if (!node) return;
		var nodeName = document.activeElement.nodeName;
		if (nodeName === "INPUT" || nodeName === "TEXTAREA" || node.contentEditable === "true") {
			if (node.blur) node.blur();
		}
	};
	
	// Check whether event is natively supported (via @kangax)
	root.getEventSupport = function (target, type) {
		if (typeof(target) === "string") {
			type = target;
			target = window;
		}
		type = "on" + type;
		if (type in target) return true;
		if (!target.setAttribute) target = document.createElement("div");
		if (target.setAttribute && target.removeAttribute) {
			target.setAttribute(type, "");
			var isSupported = typeof target[type] === "function";
			if (typeof target[type] !== "undefined") target[type] = null;
			target.removeAttribute(type);
			return isSupported;
		}
	};
	
	var clone = function (obj) {
		if (!obj || typeof (obj) !== 'object') return obj;
		var temp = new obj.constructor();
		for (var key in obj) {
			if (!obj[key] || typeof (obj[key]) !== 'object') {
				temp[key] = obj[key];
			} else { // clone sub-object
				temp[key] = clone(obj[key]);
			}
		}
		return temp;
	};
	
	/// Handle custom *EventListener commands.
	var eventManager = function(target, type, listener, configure, trigger, fromOverwrite) {
		configure = configure || {};
		// Check whether target is a configuration variable;
		if (String(target) === "[object Object]") {
			var data = target;
			target = data.target;
			type = data.type;
			listener = data.listener;
			delete data.target;
			delete data.type;
			delete data.listener;
			for (var key in data) {
				configure[key] = data[key];
			}
		}
		///
		if (!target || !type || !listener) return;
		// Check for element to load on interval (before onload).
		if (typeof(target) === "string" && type === "ready") {
			if (window.eventjs_stallOnReady) { /// force stall for scripts to load
				type = "load";
				target = window;
			} else { //
				var time = (new Date()).getTime();
				var timeout = configure.timeout;
				var ms = configure.interval || 1000 / 60;
				var interval = window.setInterval(function() {
					if ((new Date()).getTime() - time > timeout) {
						window.clearInterval(interval);
					}
					if (document.querySelector(target)) {
						window.clearInterval(interval);
						setTimeout(listener, 1);
					}
				}, ms);
				return;
			}
		}
		// Get DOM element from Query Selector.
		if (typeof(target) === "string") {
			target = document.querySelectorAll(target);
			if (target.length === 0) return createError("Missing target on listener!", arguments); // No results.
			if (target.length === 1) { // Single target.
				target = target[0];
			}
		}
	
		/// Handle multiple targets.
		var event;
		var events = {};
		if (target.length > 0 && target !== window) {
			for (var n0 = 0, length0 = target.length; n0 < length0; n0 ++) {
				event = eventManager(target[n0], type, listener, clone(configure), trigger);
				if (event) events[n0] = event;
			}
			return createBatchCommands(events);
		}
	
		/// Check for multiple events in one string.
		if (type.indexOf) {
			type = type.toLowerCase();
			if (type.indexOf(" ") !== -1) {
				type = type.split(" ");
			} else if (type.indexOf(",") !== -1) {
				type = type.split(",");
			}
		}
	
		/// Attach or remove multiple events associated with a target.
		if (typeof(type) !== "string") { // Has multiple events.
			if (typeof(type.length) === "number") { // Handle multiple listeners glued together.
				for (var n1 = 0, length1 = type.length; n1 < length1; n1 ++) { // Array [type]
					event = eventManager(target, type[n1], listener, clone(configure), trigger);
					if (event) events[type[n1]] = event;
				}
			} else { // Handle multiple listeners.
				for (var key in type) { // Object {type}
					if (typeof(type[key]) === "function") { // without configuration.
						event = eventManager(target, key, type[key], clone(configure), trigger);
					} else { // with configuration.
						event = eventManager(target, key, type[key].listener, clone(type[key]), trigger);
					}
					if (event) events[key] = event;
				}
			}
			return createBatchCommands(events);
		}
	
		// Ensure listener is a function.
		if (typeof(target) !== "object") return createError("Target is not defined!", arguments);
		if (typeof(listener) !== "function") return createError("Listener is not a function!", arguments);
	
		// Generate a unique wrapper identifier.
		var useCapture = configure.useCapture || false;
		var id = getID(target) + "." + getID(listener) + "." + (useCapture ? 1 : 0);
		// Handle the event.
		if (root.Gesture && root.Gesture._gestureHandlers[type]) { // Fire custom event.
			id = type + id;
			if (trigger === "remove") { // Remove event listener.
				if (!wrappers[id]) return; // Already removed.
				wrappers[id].remove();
				delete wrappers[id];
			} else if (trigger === "add") { // Attach event listener.
				if (wrappers[id]) {
					wrappers[id].add();
					return wrappers[id]; // Already attached.
				}
				// Retains "this" orientation.
				if (configure.useCall && !root.modifyEventListener) {
					var tmp = listener;
					listener = function(event, self) {
						for (var key in self) event[key] = self[key];
						return tmp.call(target, event);
					};
				}
				// Create listener proxy.
				configure.gesture = type;
				configure.target = target;
				configure.listener = listener;
				configure.fromOverwrite = fromOverwrite;
				// Record wrapper.
				wrappers[id] = root.proxy[type](configure);
			}
			return wrappers[id];
		} else { // Fire native event.
			var eventList = getEventList(type);
			for (var n = 0, eventId; n < eventList.length; n ++) {
				type = eventList[n];
				eventId = type + "." + id;
				if (trigger === "remove") { // Remove event listener.
					if (!wrappers[eventId]) continue; // Already removed.
					target[remove](type, listener, useCapture);
					delete wrappers[eventId];
				} else if (trigger === "add") { // Attach event listener.
					if (wrappers[eventId]) return wrappers[eventId]; // Already attached.
					target[add](type, listener, useCapture);
					// Record wrapper.
					wrappers[eventId] = {
						id: eventId,
						type: type,
						target: target,
						listener: listener,
						remove: function() {
							for (var n = 0; n < eventList.length; n ++) {
								root.remove(target, eventList[n], listener, configure);
							}
						}
					};
				}
			}
			return wrappers[eventId];
		}
	};
	
	/// Perform batch actions on multiple events.
	var createBatchCommands = function(events) {
		return {
			remove: function() { // Remove multiple events.
				for (var key in events) {
					events[key].remove();
				}
			},
			add: function() { // Add multiple events.
				for (var key in events) {
					events[key].add();
				}
			}
		};
	};
	
	/// Display error message in console.
	var createError = function(message, data) {
		if (typeof(console) === "undefined") return;
		if (typeof(console.error) === "undefined") return;
		console.error(message, data);
	};
	
	/// Handle naming discrepancies between platforms.
	var pointerDefs = {
		"msPointer": [ "MSPointerDown", "MSPointerMove", "MSPointerUp" ],
		"touch": [ "touchstart", "touchmove", "touchend" ],
		"mouse": [ "mousedown", "mousemove", "mouseup" ]
	};
	
	var pointerDetect = {
		// MSPointer
		"MSPointerDown": 0,
		"MSPointerMove": 1,
		"MSPointerUp": 2,
		// Touch
		"touchstart": 0,
		"touchmove": 1,
		"touchend": 2,
		// Mouse
		"mousedown": 0,
		"mousemove": 1,
		"mouseup": 2
	};
	
	var getEventSupport = (function() {
		root.supports = {};
		if (window.navigator.msPointerEnabled) {
			root.supports.msPointer = true;
		}
		if (root.getEventSupport("touchstart")) {
			root.supports.touch = true;
		}
		if (root.getEventSupport("mousedown")) {
			root.supports.mouse = true;
		}
	})();
	
	var getEventList = (function() {
		return function(type) {
			var prefix = document.addEventListener ? "" : "on"; // IE
			var idx = pointerDetect[type];
			if (isFinite(idx)) {
				var types = [];
				for (var key in root.supports) {
					types.push(prefix + pointerDefs[key][idx]);
				}
				return types;
			} else {
				return [ prefix + type ];
			}
		};
	})();
	
	/// Event wrappers to keep track of all events placed in the window.
	var wrappers = {};
	var counter = 0;
	var getID = function(object) {
		if (object === window) return "#window";
		if (object === document) return "#document";
		if (!object.uniqueID) object.uniqueID = "e" + counter ++;
		return object.uniqueID;
	};
	
	/// Detect platforms native *EventListener command.
	var add = document.addEventListener ? "addEventListener" : "attachEvent";
	var remove = document.removeEventListener ? "removeEventListener" : "detachEvent";
	
	/*
		Pointer.js
		------------------------
		Modified from; https://github.com/borismus/pointer.js
	*/
	
	root.createPointerEvent = function (event, self, preventRecord) {
		var eventName = self.gesture;
		var target = self.target;
		var pts = event.changedTouches || root.proxy.getCoords(event);
		if (pts.length) {
			var pt = pts[0];
			self.pointers = preventRecord ? [] : pts;
			self.pageX = pt.pageX;
			self.pageY = pt.pageY;
			self.x = self.pageX;
			self.y = self.pageY;
		}
		///
		var newEvent = document.createEvent("Event");
		newEvent.initEvent(eventName, true, true);
		newEvent.originalEvent = event;
		for (var k in self) {
			if (k === "target") continue;
			newEvent[k] = self[k];
		}
		///
		var type = newEvent.type;
		if (root.Gesture && root.Gesture._gestureHandlers[type]) { // capture custom events.
	//		target.dispatchEvent(newEvent);
			self.oldListener.call(target, newEvent, self, false);
		}
	};
	
	/// Allows *EventListener to use custom event proxies.
	if (root.modifyEventListener && window.HTMLElement) (function() {
		var augmentEventListener = function(proto) {
			var recall = function(trigger) { // overwrite native *EventListener's
				var handle = trigger + "EventListener";
				var handler = proto[handle];
				proto[handle] = function (type, listener, useCapture) {
					if (root.Gesture && root.Gesture._gestureHandlers[type]) { // capture custom events.
						var configure = useCapture;
						if (typeof(useCapture) === "object") {
							configure.useCall = true;
						} else { // convert to configuration object.
							configure = {
								useCall: true,
								useCapture: useCapture
							};
						}
						eventManager(this, type, listener, configure, trigger, true);
	//					handler.call(this, type, listener, useCapture);
					} else { // use native function.
						var types = getEventList(type);
						for (var n = 0; n < types.length; n ++) {
							handler.call(this, types[n], listener, useCapture);
						}
					}
				};
			};
			recall("add");
			recall("remove");
		};
		// NOTE: overwriting HTMLElement doesn't do anything in Firefox.
		if (navigator.userAgent.match(/Firefox/)) {
			// TODO: fix Firefox for the general case.
			augmentEventListener(HTMLDivElement.prototype);
			augmentEventListener(HTMLCanvasElement.prototype);
		} else {
			augmentEventListener(HTMLElement.prototype);
		}
		augmentEventListener(document);
		augmentEventListener(window);
	})();
	
	/// Allows querySelectorAll and other NodeLists to perform *EventListener commands in bulk.
	if (root.modifySelectors) (function() {
		var proto = NodeList.prototype;
		proto.removeEventListener = function(type, listener, useCapture) {
			for (var n = 0, length = this.length; n < length; n ++) {
				this[n].removeEventListener(type, listener, useCapture);
			}
		};
		proto.addEventListener = function(type, listener, useCapture) {
			for (var n = 0, length = this.length; n < length; n ++) {
				this[n].addEventListener(type, listener, useCapture);
			}
		};
	})();
	
	return root;
	
	})(eventjs);
	/*
		----------------------------------------------------
		eventjs.proxy : 0.4.2 : 2013/07/17 : MIT License
		----------------------------------------------------
		https://github.com/mudcube/eventjs.js
		----------------------------------------------------
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	/*
		Create a new pointer gesture instance.
	*/
	
	root.pointerSetup = function(conf, self) {
		/// Configure.
		conf.doc = conf.target.ownerDocument || conf.target; // Associated document.
		conf.minFingers = conf.minFingers || conf.fingers || 1; // Minimum required fingers.
		conf.maxFingers = conf.maxFingers || conf.fingers || Infinity; // Maximum allowed fingers.
		conf.position = conf.position || "relative"; // Determines what coordinate system points are returned.
		delete conf.fingers; //-
		/// Convenience data.
		self = self || {};
		self.enabled = true;
		self.gesture = conf.gesture;
		self.target = conf.target;
		self.env = conf.env;
		///
		if (eventjs.modifyEventListener && conf.fromOverwrite) {
			conf.oldListener = conf.listener;
			conf.listener = eventjs.createPointerEvent;
		}
		/// Convenience commands.
		var fingers = 0;
		var type = self.gesture.indexOf("pointer") === 0 && eventjs.modifyEventListener ? "pointer" : "mouse";
		if (conf.oldListener) self.oldListener = conf.oldListener;
		self.listener = conf.listener;
		self.proxy = function(listener) {
			self.defaultListener = conf.listener;
			conf.listener = listener;
			listener(conf.event, self);
		};
		self.add = function() {
			if (self.enabled === true) return;
			if (conf.onPointerDown) eventjs.add(conf.target, type + "down", conf.onPointerDown);
			if (conf.onPointerMove) eventjs.add(conf.doc, type + "move", conf.onPointerMove);
			if (conf.onPointerUp) eventjs.add(conf.doc, type + "up", conf.onPointerUp);
			self.enabled = true;
		};
		self.remove = function() {
			if (self.enabled === false) return;
			if (conf.onPointerDown) eventjs.remove(conf.target, type + "down", conf.onPointerDown);
			if (conf.onPointerMove) eventjs.remove(conf.doc, type + "move", conf.onPointerMove);
			if (conf.onPointerUp) eventjs.remove(conf.doc, type + "up", conf.onPointerUp);
			self.reset();
			self.enabled = false;
		};
		self.pause = function(opt) {
			if (conf.onPointerMove && (!opt || opt.move)) eventjs.remove(conf.doc, type + "move", conf.onPointerMove);
			if (conf.onPointerUp && (!opt || opt.up)) eventjs.remove(conf.doc, type + "up", conf.onPointerUp);
			fingers = conf.fingers;
			conf.fingers = 0;
		};
		self.resume = function(opt) {
			if (conf.onPointerMove && (!opt || opt.move)) eventjs.add(conf.doc, type + "move", conf.onPointerMove);
			if (conf.onPointerUp && (!opt || opt.up)) eventjs.add(conf.doc, type + "up", conf.onPointerUp);
			conf.fingers = fingers;
		};
		self.reset = function() {
			conf.tracker = {};
			conf.fingers = 0;
		};
		///
		return self;
	};
	
	/*
		Begin proxied pointer command.
	*/
	
	var sp = eventjs.supports; // Default pointerType
	eventjs.pointerType = sp.mouse ? "mouse" : sp.touch ? "touch" : "mspointer";
	///
	root.pointerStart = function(event, self, conf) {
		/// tracks multiple inputs
		var type = (event.type || "mousedown").toUpperCase();
		if (type.indexOf("MOUSE") === 0) {
			eventjs.pointerType = "mouse";
		} else if (type.indexOf("TOUCH") === 0) {
			eventjs.pointerType = "touch";
		} else if (type.indexOf("MSPOINTER") === 0) {
			eventjs.pointerType = "mspointer";
		}
		///
		var addTouchStart = function(touch, sid) {
			var bbox = conf.bbox;
			var pt = track[sid] = {};
			///
			switch(conf.position) {
				case "absolute": // Absolute from within window.
					pt.offsetX = 0;
					pt.offsetY = 0;
					break;
				case "differenceFromLast": // Since last coordinate recorded.
					pt.offsetX = touch.pageX;
					pt.offsetY = touch.pageY;
					break;
				case "difference": // Relative from origin.
					pt.offsetX = touch.pageX;
					pt.offsetY = touch.pageY;
					break;
				case "move": // Move target element.
					pt.offsetX = touch.pageX - bbox.x1;
					pt.offsetY = touch.pageY - bbox.y1;
					break;
				default: // Relative from within target.
					pt.offsetX = bbox.x1 - bbox.scrollLeft;
					pt.offsetY = bbox.y1 - bbox.scrollTop;
					break;
			}
			///
			var x = touch.pageX - pt.offsetX;
			var y = touch.pageY - pt.offsetY;
			///
			pt.rotation = 0;
			pt.scale = 1;
			pt.startTime = pt.moveTime = (new Date()).getTime();
			pt.move = { x: x, y: y };
			pt.start = { x: x, y: y };
			///
			conf.fingers ++;
		};
		///
		conf.event = event;
		if (self.defaultListener) {
			conf.listener = self.defaultListener;
			delete self.defaultListener;
		}
		///
		var isTouchStart = !conf.fingers;
		var track = conf.tracker;
		var touches = event.changedTouches || root.getCoords(event);
		var length = touches.length;
		// Adding touch events to tracking.
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var sid = touch.identifier || Infinity; // Touch ID.
			// Track the current state of the touches.
			if (conf.fingers) {
				if (conf.fingers >= conf.maxFingers) {
					var ids = [];
					for (var sid in conf.tracker) ids.push(sid);
					self.identifier = ids.join(",");
					return isTouchStart;
				}
				var fingers = 0; // Finger ID.
				for (var rid in track) {
					// Replace removed finger.
					if (track[rid].up) {
						delete track[rid];
						addTouchStart(touch, sid);
						conf.cancel = true;
						break;
					}
					fingers ++;
				}
				// Add additional finger.
				if (track[sid]) continue;
				addTouchStart(touch, sid);
			} else { // Start tracking fingers.
				track = conf.tracker = {};
				self.bbox = conf.bbox = root.getBoundingBox(conf.target);
				conf.fingers = 0;
				conf.cancel = false;
				addTouchStart(touch, sid);
			}
		}
		///
		var ids = [];
		for (var sid in conf.tracker) ids.push(sid);
		self.identifier = ids.join(",");
		///
		return isTouchStart;
	};
	
	/*
		End proxied pointer command.
	*/
	
	root.pointerEnd = function(event, self, conf, onPointerUp) {
		// Record changed touches have ended (iOS changedTouches is not reliable).
		var touches = event.touches || [];
		var length = touches.length;
		var exists = {};
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var sid = touch.identifier;
			exists[sid || Infinity] = true;
		}
		for (var sid in conf.tracker) {
			var track = conf.tracker[sid];
			if (exists[sid] || track.up) continue;
			if (onPointerUp) { // add changedTouches to mouse.
				onPointerUp({
					pageX: track.pageX,
					pageY: track.pageY,
					changedTouches: [{
						pageX: track.pageX,
						pageY: track.pageY,
						identifier: sid === "Infinity" ? Infinity : sid
					}]
				}, "up");
			}
			track.up = true;
			conf.fingers --;
		}
	/*	// This should work but fails in Safari on iOS4 so not using it.
		var touches = event.changedTouches || root.getCoords(event);
		var length = touches.length;
		// Record changed touches have ended (this should work).
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var sid = touch.identifier || Infinity;
			var track = conf.tracker[sid];
			if (track && !track.up) {
				if (onPointerUp) { // add changedTouches to mouse.
					onPointerUp({
						changedTouches: [{
							pageX: track.pageX,
							pageY: track.pageY,
							identifier: sid === "Infinity" ? Infinity : sid
						}]
					}, "up");
				}
				track.up = true;
				conf.fingers --;
			}
		} */
		// Wait for all fingers to be released.
		if (conf.fingers !== 0) return false;
		// Record total number of fingers gesture used.
		var ids = [];
		conf.gestureFingers = 0;
		for (var sid in conf.tracker) {
			conf.gestureFingers ++;
			ids.push(sid);
		}
		self.identifier = ids.join(",");
		// Our pointer gesture has ended.
		return true;
	};
	
	/*
		Returns mouse coords in an array to match event.*Touches
		------------------------------------------------------------
		var touch = event.changedTouches || root.getCoords(event);
	*/
	
	root.getCoords = function(event) {
		if (typeof(event.pageX) !== "undefined") { // Desktop browsers.
			root.getCoords = function(event) {
				return Array({
					type: "mouse",
					x: event.pageX,
					y: event.pageY,
					pageX: event.pageX,
					pageY: event.pageY,
					identifier: event.pointerId || Infinity // pointerId is MS
				});
			};
		} else { // Internet Explorer <= 8.0
			root.getCoords = function(event) {
				event = event || window.event;
				return Array({
					type: "mouse",
					x: event.clientX + document.documentElement.scrollLeft,
					y: event.clientY + document.documentElement.scrollTop,
					pageX: event.clientX + document.documentElement.scrollLeft,
					pageY: event.clientY + document.documentElement.scrollTop,
					identifier: Infinity
				});
			};
		}
		return root.getCoords(event);
	};
	
	/*
		Returns single coords in an object.
		------------------------------------------------------------
		var mouse = root.getCoord(event);
	*/
	
	root.getCoord = function(event) {
		if ("ontouchstart" in window) { // Mobile browsers.
			var pX = 0;
			var pY = 0;
			root.getCoord = function(event) {
				var touches = event.changedTouches;
				if (touches && touches.length) { // ontouchstart + ontouchmove
					return {
						x: pX = touches[0].pageX,
						y: pY = touches[0].pageY
					};
				} else { // ontouchend
					return {
						x: pX,
						y: pY
					};
				}
			};
		} else if(typeof(event.pageX) !== "undefined" && typeof(event.pageY) !== "undefined") { // Desktop browsers.
			root.getCoord = function(event) {
				return {
					x: event.pageX,
					y: event.pageY
				};
			};
		} else { // Internet Explorer <=8.0
			root.getCoord = function(event) {
				event = event || window.event;
				return {
					x: event.clientX + document.documentElement.scrollLeft,
					y: event.clientY + document.documentElement.scrollTop
				};
			};
		}
		return root.getCoord(event);
	};
	
	/*
		Get target scale and position in space.
	*/
	
	var getPropertyAsFloat = function(o, type) {
		var n = parseFloat(o.getPropertyValue(type), 10);
		return isFinite(n) ? n : 0;
	};
	
	root.getBoundingBox = function(o) {
		if (o === window || o === document) o = document.body;
		///
		var bbox = {};
		var bcr = o.getBoundingClientRect();
		bbox.width = bcr.width;
		bbox.height = bcr.height;
		bbox.x1 = bcr.left;
		bbox.y1 = bcr.top;
		bbox.scaleX = bcr.width / o.offsetWidth || 1;
		bbox.scaleY = bcr.height / o.offsetHeight || 1;
		bbox.scrollLeft = 0;
		bbox.scrollTop = 0;
		///
		var style = window.getComputedStyle(o);
		var left = getPropertyAsFloat(style, "border-left-width");
		var right = getPropertyAsFloat(style, "border-right-width");
		var bottom = getPropertyAsFloat(style, "border-bottom-width");
		var top = getPropertyAsFloat(style, "border-top-width");
		var border = getPropertyAsFloat(style, "border-width") * 2;
		bbox.border = [ left, right, top, bottom ];
		bbox.x1 += left;
		bbox.y1 += top;
		bbox.width -= right + left;
		bbox.height -= bottom + top;
		bbox.x2 = bbox.x1 + bbox.width;
		bbox.y2 = bbox.y1 + bbox.height;
	
		/// Get the scroll of container element.
		var position = style.getPropertyValue("position");
		var tmp = position === "fixed" ? o : o.parentNode;
		while (tmp !== null) {
			if (tmp === document.body) break;
			if (tmp.scrollTop === undefined) break;
			var style = window.getComputedStyle(tmp);
			var position = style.getPropertyValue("position");
			if (position === "absolute") {
	
			} else if (position === "fixed") {
				bbox.scrollTop -= tmp.parentNode.scrollTop;
				bbox.scrollLeft -= tmp.parentNode.scrollLeft;
				break;
			} else {
				bbox.scrollLeft += tmp.scrollLeft;
				bbox.scrollTop += tmp.scrollTop;
			}
			///
			tmp = tmp.parentNode;
		};
		///
		bbox.scrollBodyLeft = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
		bbox.scrollBodyTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
		///
		bbox.scrollLeft -= bbox.scrollBodyLeft;
		bbox.scrollTop -= bbox.scrollBodyTop;
		///
		return bbox;
	};
	
	/*
		Keep track of metaKey, the proper ctrlKey for users platform.
	*/
	
	(function() {
		var agent = navigator.userAgent.toLowerCase();
		var mac = agent.indexOf("macintosh") !== -1;
		if (mac && agent.indexOf("khtml") !== -1) { // chrome, safari.
			var watch = { 91: true, 93: true };
		} else if (mac && agent.indexOf("firefox") !== -1) {  // mac firefox.
			var watch = { 224: true };
		} else { // windows, linux, or mac opera.
			var watch = { 17: true };
		}
		root.metaTrackerReset = function() {
			root.metaKey = false;
			root.ctrlKey = false;
			root.shiftKey = false;
			root.altKey = false;
		};
		root.metaTracker = function(event) {
			var check = !!watch[event.keyCode];
			if (check) root.metaKey = event.type === "keydown";
			root.ctrlKey = event.ctrlKey;
			root.shiftKey = event.shiftKey;
			root.altKey = event.altKey;
			return check;
		};
	})();
	
	return root;
	
	})(eventjs.proxy);
	/*
		----------------------------------------------------
		"MutationObserver" event proxy.
		----------------------------------------------------
		author: Selvakumar Arumugam - MIT LICENSE
			 src: http://stackoverflow.com/questions/10868104/can-you-have-a-javascript-hook-trigger-after-a-dom-elements-style-object-change
		----------------------------------------------------
	*/
	if (typeof(eventjs) === "undefined") var eventjs = {};
	
	eventjs.MutationObserver = (function() {
		var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
		var DOMAttrModifiedSupported = !MutationObserver && (function() {
			var p = document.createElement("p");
			var flag = false;
			var fn = function() { flag = true };
			if (p.addEventListener) {
				p.addEventListener("DOMAttrModified", fn, false);
			} else if (p.attachEvent) {
				p.attachEvent("onDOMAttrModified", fn);
			} else {
				return false;
			}
			///
			p.setAttribute("id", "target");
			///
			return flag;
		})();
		///
		return function(container, callback) {
			if (MutationObserver) {
				var options = {
					subtree: false,
					attributes: true
				};
				var observer = new MutationObserver(function(mutations) {
					mutations.forEach(function(e) {
						callback.call(e.target, e.attributeName);
					});
				});
				observer.observe(container, options)
			} else if (DOMAttrModifiedSupported) {
				eventjs.add(container, "DOMAttrModified", function(e) {
					callback.call(container, e.attrName);
				});
			} else if ("onpropertychange" in document.body) {
				eventjs.add(container, "propertychange", function(e) {
					callback.call(container, window.event.propertyName);
				});
			}
		}
	})();
	/*
		"Click" event proxy.
		----------------------------------------------------
		eventjs.add(window, "click", function(event, self) {});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.click = function(conf) {
		conf.gesture = conf.gesture || "click";
		conf.maxFingers = conf.maxFingers || conf.fingers || 1;
		// Setting up local variables.
		var EVENT;
		// Tracking the events.
		conf.onPointerDown = function (event) {
			if (root.pointerStart(event, self, conf)) {
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			}
		};
		conf.onPointerMove = function (event) {
			EVENT = event;
		};
		conf.onPointerUp = function(event) {
			if (root.pointerEnd(event, self, conf)) {
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
				if (EVENT.cancelBubble && ++ EVENT.bubble > 1) return;
				var pointers = EVENT.changedTouches || root.getCoords(EVENT);
				var pointer = pointers[0];
				var bbox = conf.bbox;
				var newbbox = root.getBoundingBox(conf.target);
				var y = pointer.pageY - newbbox.scrollBodyTop;
				var x = pointer.pageX - newbbox.scrollBodyLeft;
				////
				if (x > bbox.x1 && y > bbox.y1 &&
					x < bbox.x2 && y < bbox.y2 &&
					bbox.scrollTop === newbbox.scrollTop) { // has not been scrolled
					///
					for (var key in conf.tracker) break; //- should be modularized? in dblclick too
					var point = conf.tracker[key];
					self.x = point.start.x;
					self.y = point.start.y;
					///
					conf.listener(EVENT, self);
				}
			}
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		self.state = "click";
		// Attach events.
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.click = root.click;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Double-Click" aka "Double-Tap" event proxy.
		----------------------------------------------------
		eventjs.add(window, "dblclick", function(event, self) {});
		----------------------------------------------------
		Touch an target twice for <= 700ms, with less than 25 pixel drift.
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.dbltap =
	root.dblclick = function(conf) {
		conf.gesture = conf.gesture || "dbltap";
		conf.maxFingers = conf.maxFingers || conf.fingers || 1;
		// Setting up local variables.
		var delay = 700; // in milliseconds
		var time0, time1, timeout;
		var pointer0, pointer1;
		// Tracking the events.
		conf.onPointerDown = function (event) {
			var pointers = event.changedTouches || root.getCoords(event);
			if (time0 && !time1) { // Click #2
				pointer1 = pointers[0];
				time1 = (new Date()).getTime() - time0;
			} else { // Click #1
				pointer0 = pointers[0];
				time0 = (new Date()).getTime();
				time1 = 0;
				clearTimeout(timeout);
				timeout = setTimeout(function() {
					time0 = 0;
				}, delay);
			}
			if (root.pointerStart(event, self, conf)) {
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			}
		};
		conf.onPointerMove = function (event) {
			if (time0 && !time1) {
				var pointers = event.changedTouches || root.getCoords(event);
				pointer1 = pointers[0];
			}
			var bbox = conf.bbox;
			var ax = (pointer1.pageX - bbox.x1);
			var ay = (pointer1.pageY - bbox.y1);
			if (!(ax > 0 && ax < bbox.width && // Within target coordinates..
					ay > 0 && ay < bbox.height &&
					Math.abs(pointer1.pageX - pointer0.pageX) <= 25 && // Within drift deviance.
					Math.abs(pointer1.pageY - pointer0.pageY) <= 25)) {
				// Cancel out this listener.
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				clearTimeout(timeout);
				time0 = time1 = 0;
			}
		};
		conf.onPointerUp = function(event) {
			if (root.pointerEnd(event, self, conf)) {
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
			}
			if (time0 && time1) {
				if (time1 <= delay && !(event.cancelBubble && ++event.bubble > 1)) {
					self.state = conf.gesture;
					for (var key in conf.tracker) break;
					var point = conf.tracker[key];
					self.x = point.start.x;
					self.y = point.start.y;
					conf.listener(event, self);
				}
				clearTimeout(timeout);
				time0 = time1 = 0;
			}
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		self.state = "dblclick";
		// Attach events.
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.dbltap = root.dbltap;
	eventjs.Gesture._gestureHandlers.dblclick = root.dblclick;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Drag" event proxy (1+ fingers).
		----------------------------------------------------
		CONFIGURE: maxFingers, position.
		----------------------------------------------------
		eventjs.add(window, "drag", function(event, self) {
			console.log(self.gesture, self.state, self.start, self.x, self.y, self.bbox);
		});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.dragElement = function(that, event) {
		root.drag({
			event: event,
			target: that,
			position: "move",
			listener: function(event, self) {
				that.style.left = self.x + "px";
				that.style.top = self.y + "px";
				eventjs.prevent(event);
			}
		});
	};
	
	root.drag = function(conf) {
		conf.gesture = "drag";
		conf.onPointerDown = function (event) {
			if (root.pointerStart(event, self, conf)) {
				if (!conf.monitor) {
					eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
					eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
				}
			}
			// Process event listener.
			conf.onPointerMove(event, "down");
		};
		conf.onPointerMove = function (event, state) {
			if (!conf.tracker) return conf.onPointerDown(event);
			var bbox = conf.bbox;
			var touches = event.changedTouches || root.getCoords(event);
			var length = touches.length;
			for (var i = 0; i < length; i ++) {
				var touch = touches[i];
				var identifier = touch.identifier || Infinity;
				var pt = conf.tracker[identifier];
				// Identifier defined outside of listener.
				if (!pt) continue;
				pt.pageX = touch.pageX;
				pt.pageY = touch.pageY;
				// Record data.
				self.state = state || "move";
				self.identifier = identifier;
				self.start = pt.start;
				self.fingers = conf.fingers;
				if (conf.position === "differenceFromLast") {
					self.x = (pt.pageX - pt.offsetX);
					self.y = (pt.pageY - pt.offsetY);
					pt.offsetX = pt.pageX;
					pt.offsetY = pt.pageY;
				} else {
					self.x = (pt.pageX - pt.offsetX);
					self.y = (pt.pageY - pt.offsetY);
				}
				///
				conf.listener(event, self);
			}
		};
		conf.onPointerUp = function(event) {
			// Remove tracking for touch.
			if (root.pointerEnd(event, self, conf, conf.onPointerMove)) {
				if (!conf.monitor) {
					eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
					eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
				}
			}
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		// Attach events.
		if (conf.event) {
			conf.onPointerDown(conf.event);
		} else { //
			eventjs.add(conf.target, "mousedown", conf.onPointerDown);
			if (conf.monitor) {
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			}
		}
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.drag = root.drag;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Gesture" event proxy (2+ fingers).
		----------------------------------------------------
		CONFIGURE: minFingers, maxFingers.
		----------------------------------------------------
		eventjs.add(window, "gesture", function(event, self) {
			console.log(self.rotation, self.scale, self.fingers, self.state);
		});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	var RAD_DEG = Math.PI / 180;
	
	root.gesture = function(conf) {
		conf.gesture = conf.gesture || "gesture";
		conf.minFingers = conf.minFingers || conf.fingers || 2;
		// Tracking the events.
		conf.onPointerDown = function (event) {
			var fingers = conf.fingers;
			if (root.pointerStart(event, self, conf)) {
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			}
			// Record gesture start.
			if (conf.fingers === conf.minFingers && fingers !== conf.fingers) {
				self.fingers = conf.minFingers;
				self.scale = 1;
				self.rotation = 0;
				self.state = "start";
				var sids = ""; //- FIXME(mud): can generate duplicate IDs.
				for (var key in conf.tracker) sids += key;
				self.identifier = parseInt(sids);
				conf.listener(event, self);
			}
		};
		///
		conf.onPointerMove = function (event, state) {
			var bbox = conf.bbox;
			var points = conf.tracker;
			var touches = event.changedTouches || root.getCoords(event);
			var length = touches.length;
			// Update tracker coordinates.
			for (var i = 0; i < length; i ++) {
				var touch = touches[i];
				var sid = touch.identifier || Infinity;
				var pt = points[sid];
				// Check whether "pt" is used by another gesture.
				if (!pt) continue;
				// Find the actual coordinates.
				pt.move.x = (touch.pageX - bbox.x1);
				pt.move.y = (touch.pageY - bbox.y1);
			}
			///
			if (conf.fingers < conf.minFingers) return;
			///
			var touches = [];
			var scale = 0;
			var rotation = 0;
			/// Calculate centroid of gesture.
			var centroidx = 0;
			var centroidy = 0;
			var length = 0;
			for (var sid in points) {
				var touch = points[sid];
				if (touch.up) continue;
				centroidx += touch.move.x;
				centroidy += touch.move.y;
				length ++;
			}
			centroidx /= length;
			centroidy /= length;
			///
			for (var sid in points) {
				var touch = points[sid];
				if (touch.up) continue;
				var start = touch.start;
				if (!start.distance) {
					var dx = start.x - centroidx;
					var dy = start.y - centroidy;
					start.distance = Math.sqrt(dx * dx + dy * dy);
					start.angle = Math.atan2(dx, dy) / RAD_DEG;
				}
				// Calculate scale.
				var dx = touch.move.x - centroidx;
				var dy = touch.move.y - centroidy;
				var distance = Math.sqrt(dx * dx + dy * dy);
				scale += distance / start.distance;
				// Calculate rotation.
				var angle = Math.atan2(dx, dy) / RAD_DEG;
				var rotate = (start.angle - angle + 360) % 360 - 180;
				touch.DEG2 = touch.DEG1; // Previous degree.
				touch.DEG1 = rotate > 0 ? rotate : -rotate; // Current degree.
				if (typeof(touch.DEG2) !== "undefined") {
					if (rotate > 0) {
						touch.rotation += touch.DEG1 - touch.DEG2;
					} else {
						touch.rotation -= touch.DEG1 - touch.DEG2;
					}
					rotation += touch.rotation;
				}
				// Attach current points to self.
				touches.push(touch.move);
			}
			///
			self.touches = touches;
			self.fingers = conf.fingers;
			self.scale = scale / conf.fingers;
			self.rotation = rotation / conf.fingers;
			self.state = "change";
			conf.listener(event, self);
		};
		conf.onPointerUp = function(event) {
			// Remove tracking for touch.
			var fingers = conf.fingers;
			if (root.pointerEnd(event, self, conf)) {
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
			}
			// Check whether fingers has dropped below minFingers.
			if (fingers === conf.minFingers && conf.fingers < conf.minFingers) {
				self.fingers = conf.fingers;
				self.state = "end";
				conf.listener(event, self);
			}
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		// Attach events.
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.gesture = root.gesture;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Pointer" event proxy (1+ fingers).
		----------------------------------------------------
		CONFIGURE: minFingers, maxFingers.
		----------------------------------------------------
		eventjs.add(window, "gesture", function(event, self) {
			console.log(self.rotation, self.scale, self.fingers, self.state);
		});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.pointerdown =
	root.pointermove =
	root.pointerup = function(conf) {
		conf.gesture = conf.gesture || "pointer";
		if (conf.target.isPointerEmitter) return;
		// Tracking the events.
		var isDown = true;
		conf.onPointerDown = function (event) {
			isDown = false;
			self.gesture = "pointerdown";
			conf.listener(event, self);
		};
		conf.onPointerMove = function (event) {
			self.gesture = "pointermove";
			conf.listener(event, self, isDown);
		};
		conf.onPointerUp = function (event) {
			isDown = true;
			self.gesture = "pointerup";
			conf.listener(event, self, true);
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		// Attach events.
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		eventjs.add(conf.target, "mousemove", conf.onPointerMove);
		eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
		// Return this object.
		conf.target.isPointerEmitter = true;
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.pointerdown = root.pointerdown;
	eventjs.Gesture._gestureHandlers.pointermove = root.pointermove;
	eventjs.Gesture._gestureHandlers.pointerup = root.pointerup;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Device Motion" and "Shake" event proxy.
		----------------------------------------------------
		http://developer.android.com/reference/android/hardware/Sensoreventjs.html#values
		----------------------------------------------------
		eventjs.add(window, "shake", function(event, self) {});
		eventjs.add(window, "devicemotion", function(event, self) {
			console.log(self.acceleration, self.accelerationIncludingGravity);
		});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.shake = function(conf) {
		// Externally accessible data.
		var self = {
			gesture: "devicemotion",
			acceleration: {},
			accelerationIncludingGravity: {},
			target: conf.target,
			listener: conf.listener,
			remove: function() {
				window.removeEventListener('devicemotion', onDeviceMotion, false);
			}
		};
		// Setting up local variables.
		var threshold = 4; // Gravitational threshold.
		var timeout = 1000; // Timeout between shake events.
		var timeframe = 200; // Time between shakes.
		var shakes = 3; // Minimum shakes to trigger event.
		var lastShake = (new Date()).getTime();
		var gravity = { x: 0, y: 0, z: 0 };
		var delta = {
			x: { count: 0, value: 0 },
			y: { count: 0, value: 0 },
			z: { count: 0, value: 0 }
		};
		// Tracking the events.
		var onDeviceMotion = function(e) {
			var alpha = 0.8; // Low pass filter.
			var o = e.accelerationIncludingGravity;
			gravity.x = alpha * gravity.x + (1 - alpha) * o.x;
			gravity.y = alpha * gravity.y + (1 - alpha) * o.y;
			gravity.z = alpha * gravity.z + (1 - alpha) * o.z;
			self.accelerationIncludingGravity = gravity;
			self.acceleration.x = o.x - gravity.x;
			self.acceleration.y = o.y - gravity.y;
			self.acceleration.z = o.z - gravity.z;
			///
			if (conf.gesture === "devicemotion") {
				conf.listener(e, self);
				return;
			}
			var data = "xyz";
			var now = (new Date()).getTime();
			for (var n = 0, length = data.length; n < length; n ++) {
				var letter = data[n];
				var ACCELERATION = self.acceleration[letter];
				var DELTA = delta[letter];
				var abs = Math.abs(ACCELERATION);
				/// Check whether another shake event was recently registered.
				if (now - lastShake < timeout) continue;
				/// Check whether delta surpasses threshold.
				if (abs > threshold) {
					var idx = now * ACCELERATION / abs;
					var span = Math.abs(idx + DELTA.value);
					// Check whether last delta was registered within timeframe.
					if (DELTA.value && span < timeframe) {
						DELTA.value = idx;
						DELTA.count ++;
						// Check whether delta count has enough shakes.
						if (DELTA.count === shakes) {
							conf.listener(e, self);
							// Reset tracking.
							lastShake = now;
							DELTA.value = 0;
							DELTA.count = 0;
						}
					} else {
						// Track first shake.
						DELTA.value = idx;
						DELTA.count = 1;
					}
				}
			}
		};
		// Attach events.
		if (!window.addEventListener) return;
		window.addEventListener('devicemotion', onDeviceMotion, false);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.shake = root.shake;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Swipe" event proxy (1+ fingers).
		----------------------------------------------------
		CONFIGURE: snap, threshold, maxFingers.
		----------------------------------------------------
		eventjs.add(window, "swipe", function(event, self) {
			console.log(self.velocity, self.angle);
		});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	var RAD_DEG = Math.PI / 180;
	
	root.swipe = function(conf) {
		conf.snap = conf.snap || 90; // angle snap.
		conf.threshold = conf.threshold || 1; // velocity threshold.
		conf.gesture = conf.gesture || "swipe";
		// Tracking the events.
		conf.onPointerDown = function (event) {
			if (root.pointerStart(event, self, conf)) {
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			}
		};
		conf.onPointerMove = function (event) {
			var touches = event.changedTouches || root.getCoords(event);
			var length = touches.length;
			for (var i = 0; i < length; i ++) {
				var touch = touches[i];
				var sid = touch.identifier || Infinity;
				var o = conf.tracker[sid];
				// Identifier defined outside of listener.
				if (!o) continue;
				o.move.x = touch.pageX;
				o.move.y = touch.pageY;
				o.moveTime = (new Date()).getTime();
			}
		};
		conf.onPointerUp = function(event) {
			if (root.pointerEnd(event, self, conf)) {
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
				///
				var velocity1;
				var velocity2
				var degree1;
				var degree2;
				/// Calculate centroid of gesture.
				var start = { x: 0, y: 0 };
				var endx = 0;
				var endy = 0;
				var length = 0;
				///
				for (var sid in conf.tracker) {
					var touch = conf.tracker[sid];
					var xdist = touch.move.x - touch.start.x;
					var ydist = touch.move.y - touch.start.y;
					///
					endx += touch.move.x;
					endy += touch.move.y;
					start.x += touch.start.x;
					start.y += touch.start.y;
					length ++;
					///
					var distance = Math.sqrt(xdist * xdist + ydist * ydist);
					var ms = touch.moveTime - touch.startTime;
					var degree2 = Math.atan2(xdist, ydist) / RAD_DEG + 180;
					var velocity2 = ms ? distance / ms : 0;
					if (typeof(degree1) === "undefined") {
						degree1 = degree2;
						velocity1 = velocity2;
					} else if (Math.abs(degree2 - degree1) <= 20) {
						degree1 = (degree1 + degree2) / 2;
						velocity1 = (velocity1 + velocity2) / 2;
					} else {
						return;
					}
				}
				///
				var fingers = conf.gestureFingers;
				if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
					if (velocity1 > conf.threshold) {
						start.x /= length;
						start.y /= length;
						self.start = start;
						self.x = endx / length;
						self.y = endy / length;
						self.angle = -((((degree1 / conf.snap + 0.5) >> 0) * conf.snap || 360) - 360);
						self.velocity = velocity1;
						self.fingers = fingers;
						self.state = "swipe";
						conf.listener(event, self);
					}
				}
			}
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		// Attach events.
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.swipe = root.swipe;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Tap" and "Longpress" event proxy.
		----------------------------------------------------
		CONFIGURE: delay (longpress), timeout (tap).
		----------------------------------------------------
		eventjs.add(window, "tap", function(event, self) {
			console.log(self.fingers);
		});
		----------------------------------------------------
		multi-finger tap // touch an target for <= 250ms.
		multi-finger longpress // touch an target for >= 500ms
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.longpress = function(conf) {
		conf.gesture = "longpress";
		return root.tap(conf);
	};
	
	root.tap = function(conf) {
		conf.delay = conf.delay || 500;
		conf.timeout = conf.timeout || 250;
		conf.driftDeviance = conf.driftDeviance || 10;
		conf.gesture = conf.gesture || "tap";
		// Setting up local variables.
		var timestamp, timeout;
		// Tracking the events.
		conf.onPointerDown = function (event) {
			if (root.pointerStart(event, self, conf)) {
				timestamp = (new Date()).getTime();
				// Initialize event listeners.
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
				// Make sure this is a "longpress" event.
				if (conf.gesture !== "longpress") return;
				timeout = setTimeout(function() {
					if (event.cancelBubble && ++event.bubble > 1) return;
					// Make sure no fingers have been changed.
					var fingers = 0;
					for (var key in conf.tracker) {
						var point = conf.tracker[key];
						if (point.end === true) return;
						if (conf.cancel) return;
						fingers ++;
					}
					// Send callback.
					if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
						self.state = "start";
						self.fingers = fingers;
						self.x = point.start.x;
						self.y = point.start.y;
						conf.listener(event, self);
					}
				}, conf.delay);
			}
		};
		conf.onPointerMove = function (event) {
			var bbox = conf.bbox;
			var touches = event.changedTouches || root.getCoords(event);
			var length = touches.length;
			for (var i = 0; i < length; i ++) {
				var touch = touches[i];
				var identifier = touch.identifier || Infinity;
				var pt = conf.tracker[identifier];
				if (!pt) continue;
				var x = (touch.pageX - bbox.x1);
				var y = (touch.pageY - bbox.y1);
				///
				var dx = x - pt.start.x;
				var dy = y - pt.start.y;
				var distance = Math.sqrt(dx * dx + dy * dy);
				if (!(x > 0 && x < bbox.width && // Within target coordinates..
						y > 0 && y < bbox.height &&
						distance <= conf.driftDeviance)) { // Within drift deviance.
					// Cancel out this listener.
					eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
					conf.cancel = true;
					return;
				}
			}
		};
		conf.onPointerUp = function(event) {
			if (root.pointerEnd(event, self, conf)) {
				clearTimeout(timeout);
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
				if (event.cancelBubble && ++event.bubble > 1) return;
				// Callback release on longpress.
				if (conf.gesture === "longpress") {
					if (self.state === "start") {
						self.state = "end";
						conf.listener(event, self);
					}
					return;
				}
				// Cancel event due to movement.
				if (conf.cancel) return;
				// Ensure delay is within margins.
				if ((new Date()).getTime() - timestamp > conf.timeout) return;
				// Send callback.
				var fingers = conf.gestureFingers;
				if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
					self.state = "tap";
					self.fingers = conf.gestureFingers;
					conf.listener(event, self);
				}
			}
		};
		// Generate maintenance commands, and other configurations.
		var self = root.pointerSetup(conf);
		// Attach events.
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.tap = root.tap;
	eventjs.Gesture._gestureHandlers.longpress = root.longpress;
	
	return root;
	
	})(eventjs.proxy);
	/*
		"Mouse Wheel" event proxy.
		----------------------------------------------------
		eventjs.add(window, "wheel", function(event, self) {
			console.log(self.state, self.wheelDelta);
		});
	*/
	
	if (typeof(eventjs) === "undefined") var eventjs = {};
	if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
	
	eventjs.proxy = (function(root) { "use strict";
	
	root.wheelPreventElasticBounce = function(el) {
		if (!el) return;
		if (typeof(el) === "string") el = document.querySelector(el);
		Event.add(el, "wheel", function(event, self) {
			self.preventElasticBounce();
			eventjs.stop(event);
		});
	};
	
	root.wheel = function(conf) {
		// Configure event listener.
		var interval;
		var timeout = conf.timeout || 150;
		var count = 0;
		// Externally accessible data.
		var self = {
			gesture: "wheel",
			state: "start",
			wheelDelta: 0,
			target: conf.target,
			listener: conf.listener,
			preventElasticBounce: function(event) {
				var target = this.target;
				var scrollTop = target.scrollTop;
				var top = scrollTop + target.offsetHeight;
				var height = target.scrollHeight;
				if (top === height && this.wheelDelta <= 0) eventjs.cancel(event);
				else if (scrollTop === 0 && this.wheelDelta >= 0) eventjs.cancel(event);
				eventjs.stop(event);
			},
			add: function() {
				conf.target[add](type, onMouseWheel, false);
			},
			remove: function() {
				conf.target[remove](type, onMouseWheel, false);
			}
		};
		// Tracking the events.
		var onMouseWheel = function(event) {
			event = event || window.event;
			self.state = count++ ? "change" : "start";
			self.wheelDelta = event.detail ? event.detail * -20 : event.wheelDelta;
			conf.listener(event, self);
			clearTimeout(interval);
			interval = setTimeout(function() {
				count = 0;
				self.state = "end";
				self.wheelDelta = 0;
				conf.listener(event, self);
			}, timeout);
		};
		// Attach events.
		var add = document.addEventListener ? "addEventListener" : "attachEvent";
		var remove = document.removeEventListener ? "removeEventListener" : "detachEvent";
		var type = eventjs.getEventSupport("mousewheel") ? "mousewheel" : "DOMMouseScroll";
		conf.target[add](type, onMouseWheel, false);
		// Return this object.
		return self;
	};
	
	eventjs.Gesture = eventjs.Gesture || {};
	eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
	eventjs.Gesture._gestureHandlers.wheel = root.wheel;
	
	return root;
	
	})(eventjs.proxy);
	
	///
	var addEvent = eventjs.add;
	var removeEvent = eventjs.remove;
	///
	(function() {
		for (var key in eventjs) {
			Event[key] = eventjs[key];
		}
		for (var key in eventjs.proxy) {
			addEvent[key] = eventjs.proxy[key];
		}
	})();
	var ColorSphereBackground = function(params) {
	var that = this;
	///
	this.create = function(params) {
		params = params || {};
		var element = params.element;
		params.x = params.x || 0;
		params.y = params.y || 0;
		params.width = params.width || Math.max(window.innerWidth, element.offsetWidth);
		params.height = params.height || element.offsetHeight || window.innerHeight;
		///
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext("2d");
		canvas.style.cssText = "position: absolute; left: 0; top: 0; opacity: 1; z-index: 0";
		canvas.style.width = params.width + "px";
		canvas.style.height = params.height + "px";
		element.appendChild(canvas);
		///
		var theSphere;
		var px = window.innerWidth / 2.0;
		var py = window.innerHeight / 2.0;
		var onMouseMove = function(event) {
			ctx.drawImage(theSphere, 0, 0);
			if (event) {
				var coords = Event.proxy.getCoord(event);
				coords.x -= document.body.scrollLeft;
				coords.y -= document.body.scrollTop;
				px = coords.x;
				py = coords.y;
			} else { //
				var coords = { x: px, y: py };
			}
			//
			var x = Math.max(0.1,coords.x / window.innerWidth) * 255 - 127; // grab mouse pixel coords, center at midpoint
			var y = Math.max(0.4,coords.y / window.innerHeight) * 255 - 127;
			var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); // get image data
			var data = imageData.data;
			for(var n = 0, length = data.length; n < length; n += 4) {
				data[n] = data[n] + x - y; // red (control left)
				data[n + 1] = data[n + 1] - x - y; // green (control right)
				data[n + 2] = data[n + 2] + y + y; // blue (control down)
			}
			ctx.putImageData(imageData, 0, 0);
		};
		//
		function getDocHeight() {
			var D = document;
			return Math.max(
				Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
				Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
				Math.max(D.body.clientHeight, D.documentElement.clientHeight)
			);
		};
		var percent = 1 - document.body.scrollTop / getDocHeight();
		ctx.drawImage(theSphere = that.sphere(params, canvas, percent), 0, 0);
		///
		Event.add(document, "mousemove", onMouseMove);
		Event.add(document, "scroll", function(e) {
			var percent = 1 - document.body.scrollTop / document.body.scrollHeight;
			ctx.drawImage(theSphere = that.sphere(params, canvas, percent), 0, 0);
			onMouseMove();
		});
		Event.add(window, "resize", function() {
			canvas.style.width = Math.max(window.innerWidth, element.offsetWidth) + "px";
			canvas.style.height = params.height + "px";
			ctx.drawImage(theSphere = that.sphere(params, canvas, percent), 0, 0)
		});
	};
	///
	this.sphere = function (params, canvas, top) { // create Sphere image, and apply to <canvas>
		var canvas1 = document.createElement("canvas");
		var ctx = canvas1.getContext("2d");
		var w = 50;
		var left = params.x - w / 2;
		var top = top * params.y - w;
		canvas.width = canvas1.width = w * window.innerWidth / window.innerHeight;
		canvas.height = canvas1.height = w;
		ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
		///
		var n = 360; while(n--) { // go through hues
			var x = left + w;
			var y = top + w*2;
			var g = ctx.createLinearGradient(x, parseFloat(top), x, y);
			g.addColorStop(0, "rgba(0,0,0,0)");
			g.addColorStop(.5, "hsl("+((n + 60) % 360)+",100%,50%)");
			g.addColorStop(1, "#FFF");
			ctx.beginPath(); // draw triangle
			ctx.moveTo(x, top);
			ctx.lineTo(x, y);
			ctx.lineTo(x + 2, y);
			ctx.lineTo(x + 5, top);
			ctx.fillStyle = g; // apply gradient
			ctx.fill();
			ctx.translate(x, y); // rotate + translate into position
			ctx.rotate((1 / 360) * Math.PI * 2);
			ctx.translate(-x, -y);
		}
		return canvas1;
	};
	///
	for (var n = 0; n < params.length; n ++) {
		this.create(params[n]);
	}
};


	</script>
	
	<div id="footer"><canvas style="position: absolute; left: 0px; top: 0px; opacity: 1; z-index: 0; width: 702px; height: 250px;" width="39" height="50"></canvas></div>
	<script language="JavaScript">var cs = new ColorSphereBackground([{ element: document.querySelector('#footer') }]);</script>
	<script>
	document.addEventListener('DOMContentLoaded',()=>{
		var _uri=new URL(location.href);
		var url=_uri.searchParams.get('url');
		var file=_uri.searchParams.get('file');
		if(url)
			url=decodeURIComponent(url);
		if(file)
			file=decodeURIComponent(file);

		$.toolbox(url,file);		
	});
	</script>
</body>
</html>
